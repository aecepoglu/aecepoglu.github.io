---
title: "NodeJS'te Maybe Monad'ını Kullanarak REPL-Destekli Kod Yazma"
---

= Türkiye'de OCaml İş İmkanları: ya da NodeJS'te Maybe Monad'ını Kullanarak REPL-Destekli Kod Yazma
aecepoglu
v0.1, 2019-07-28
:icons: font
:experimental:
:source-highlighter: rouge

http://discuss.ocaml.org 'u açıyorum; uzun zamandır portfolyomu fonksiyonel yaklaşımlar ve diller konusunda zenginleştirmekteyim ve de aktif bir iş arayışındayım. İnternette bir OCaml ilanı var ise orada bulabileceğimden eminim.

Komşu başlıklardan birisinde "Closure'da REPL Driven Development" yapmanın ne kadar keyifli olduğunu, acaba OCaml'da da bunun mümkün olup olmadığı tartışılıyor.

[quote]
____

I want to define “Repl based development” not as “occasionally use the REPL”, but something like this:

we start a REPL
we type code in some editor, and continuously “send last expression” to the REPL, and we look at the new output
eventually, we clean up the buffer a bit and store it as code
____

_REPL Driven Development ne?_ +
_Piyasada benim bilmediğim yeni bir moda akımı mı var?_ +
_Derhal araştırmaya koyuluyorum..._

== Read-Eval-Print-Loop

Herhangi bir "interpreted" dil ile kod yazmış iseniz, adina "REPL" dendiğini bilmeseniz de bir REPL arayüzüne denk gelmişsinizdir.

.Python3 REPL
[caption="Ornegin: "]
image::https://media.giphy.com/media/L3E1mat1ji5WEVy33V/giphy.gif[GIF]

REPL programı:

. Kullanıcıdan bir satir kod ister (**R**ead)
. Sonucunu hesaplar (**E**val)
. Ekrana yazdırır (**P**rint)
. 1'inci adıma dönerek sonsuz bir döngü oluşturur (**L**oop)

REPL programı (kbd:[ctrl-c] veya kbd:[ctrl-d] ile) sonlandırılıncaya kadar bu döngüde kalarak girdilerinizi hesaplar. Ama ben bu sistemi hesap makinesinden öte bir şey icin henüz kullanabilmiş değilim.

== REPL ile Kod Geliştirmek

REPL'i yazılım geliştirme surecinin merkezine oturtmak icin JVM'e hapsolmuş bir LISP kullanmak zorunda değilsiniz (https://root.cern.ch/cling[C dili icin bile REPL bulunabiliyor]). LISP programcıları uzun bir süredir kodlarını (metodlarını) istedikleri şeyi yapana kadar REPL'de geliştirip sonra da bir dosyaya kaydediyorlar. `npm install mocha` demeden, kalite mühendisleri tepelerinde dikilmeden doğal bir şekilde Test-Driven-Development yapıyorlar. Bunu yaparken de REPL ile entegre bir kod geliştirme ortamından faydalanıyorlar.

Bir yazılımcının hangi kod geliştirme ortamini kullanacağı tamamen şahsi bir tercihtir; aynen sert zeminli bir ofiste işini yapmaya odaklanmış 20 mühendisin arasından günde 20 defa geçeceğini bile bile topuklu ayakkabı giymek gibi.

Siz kod yazmak için:

. Vim/NeoVim gibi bir metin düzenleyici kullanıyor olabilirsiniz,
. NetBeans gibi bir IDE kullanıyor olabilirsiniz,
. Emacs gibi bir işletim sistemi kullanıyor olabilirsiniz,

.XKCD
[caption="Ilgili "]
image::https://imgs.xkcd.com/comics/real_programmers.png[GIF]

Ve de REPL'le entegre bir şekilde kod yazıp yazamayacağınız ortamınızın bunu destekleyip desteklemediğine bakar.

Ve tam bu arada ben birkaç hafta önce http://neovim.io[NeoVim]'den http://kakoune.org[Kakoune]'a geçtiğimi, Kakoune'da `:repl` komutuna denk gelip ne yaptığını anlamadığımı hatırlıyorum.

NOTE: Kakoune, "kakuun" diye okunur.

== Kakoune/REPL Entegrasyonu

.Kakoune'den Bash REPL'iyle konuşma
[caption="Ornegin: "]
image::https://media.giphy.com/media/H7Sd0Zr8ESnpExHgfz/giphy.gif[GIF]

TIP: Bu arada Bash/Sh'nin de bir REPL olduğunu farkediyoruz

Kakoune'da bu işi yapabilmemizi sağlayan iki komut var:

. `:repl` yeni bir pencere pencere açar
. `:send-text` ise `:repl` komutuyla açılmış pencereyi bulup, seçilen metni ona yollar

Kakoune'un pencereleri pencere yöneticisi seviyesinde (X11) veya Tmux'un içinde olabiliyor. Kakoune hangi ortamda çalıştığını anlayıp ona göre davranıyor.

[NOTE]
====
Ben `:send-text` yazmaya usendigim icin kbd:[#] tusunu `:send-text` komutuna kisayol atadim

.kakrc
----
map global normal <#> ":send-text"
----
====

== REPL destegiyle NodeJS yazmak

REPL'le nasıl konuşacağımı oğrendiğime göre, örnek bir problem çözerek bunu bir denemek istiyorum. http://exercism.io 'da geldiğim son probleme bakalım:

=== Luhn doğrulama problemi

Kredi kartı vb numaralarının geçerliligini bulmada kullanılıyor.

Bir string alıp bunun Luhn algoritmasınca gecerli bir sayi olup olmadığını hesaplayın.

. String'in boyu 1'den az olamaz
. Boşluk olabilir ama hesaplamaya başlanmadan silinmelidir
+
mesela bize verilen metin şu olsun: `4539 1488 0343 6467`
+
boşluklarını silelim: `4539148803436467`

. Bunlar haricinde rakam dışında bir karakter olamaz
. En sağdan baslayıp her ikinci rakamı ikiyle carpın
. Carpım sonucunda 10 veya daha büyük bir sayı bulduysanız 9 çıkarın
+
bu sayıyı elde ettik: `8569247803833437`

. Tum rakamları toplayın
+
sonuç `80`

. Sonuç 10 ile bölunebiliyor ise geçerli bir sayıdır, yoksa değildir

[.lead]
Sizi bilmiyorum ama, ben iç içe (ya da peş peşe )bu kadar `if else` yazmak istemem. Hele de böylesine _beni fonksiyonel yaz!_ diyen, _once bunu yap, sonra bunu yap_ şeklinde bir algoritma var ise `Maybe` kullanmak isterim.

=== Maybe haznesi

Maybe; doğrulugundan emin olmadığınız değerleri içerisine koyup, uzerinde işlem yapabileceğiniz bir hazne. 

Önce bir örnek gösterip sonra açıklamasını yapacağım.

Bir metod yazalım, bu metod bir sayıyla çağırılmış olabilir, veya hiçbir sey verilmeden çağırılmış da olabilir. Biz bunu 3'le çarpıp 2 ekleyelim...

.kod
[source,javascript]
----
const foo = num => {
  return Maybe.of(num)         //Just(num) veya Nothing'imiz olacak
              .map(x => x * 3) //Just(x)'i Just(3*x) haline getirecek
                               // Nothing ise ona dokunmayacak
              .map(x => x + 2) //Just(3*x)'i Just(3*x + 2) yapacak
                               // Nothing ise ona dokunmayacak
              .withDefault(0)  //3x+2 ya da 0 donecek
}
----

Maybe'ye koyduğunuz değerler ya _Bir Sey_ olarak tutulur, ya da _Hicbir Sey_. Eğer _Hicbir Sey_'iniz var ise yapacak bir sey yok zaten. Ama eğer _Bir Sey_ iniz var ise o değeri metodlar vererek güncelleyebilirsiniz.+

[TIP] 
====
`Maybe/BirSey/HicbirSey` uclemesi farkli dillerde farkli isimlerde duyulabiliyor. Benim bildiklerim: +

. OCaml'da `option/Some/None`
. Haskell'de `Maybe/Just/Nothing`

====

JavaScript'te Maybe ve benzeri fonksiyonel tanımları içeren kutüphaneler mevcut ama kendimizinkini yazmak da 2dk'mızı alacak.

.JavaScript Maybe kodu
[source,javascript]
----
class Maybe {
  static of(x)   { return x
                    ? new Just(x)
                    : new Nothing() }
}
class Just extends Maybe {
  constructor(x) { super();
                   this.$value = x }
  map(f)         { return new Just( f(this.$value) ) }
  chain(f)       { return f(this.$value) }
  withDefault()  { return this.$value }
  toString()     { return `Just ${this.value}` }
}
class Nothing extends Maybe {
  map()          { return this }
  chain()        { return this }
  withDefault(x) { return x }
  toString()     { return "Nothing" }
}
----

NodeJS REPL'ine test değerleri yolluyorum...

++++
 <iframe src='https://gfycat.com/ifr/TangibleGargantuanFossa' frameborder='0' scrolling='no' allowfullscreen width='640' height='390'></iframe>
++++

Unutmayayım diye bunlari da koduma kopyalıyorum.
İstediğim sonucu veriyor mu diye de kontrol edeceğim.
Bunları koduma koyduğum için de bu kod yaşadığı sürece bu test yapılıyor olacak.

.Test kodu
[source,javascript]
----
const fail = msg => { throw new Error(msg) }

new Just(4).map(x => x + 2).withDefault(0) == 6 || fail("Just map withDefault")
new Nothing().map(x => x + 2).withDefault(0) == 0 || fail("Nothing map withDefault")
----

Maybe'ye dair yapmak istediğim 1 adet şey kaldi.

`Maybe.of` Maybe'nin içerisine değer koymak için ideal bir yöntem değil. Bir değerin `truthy` olup olmamasından ötesiyle ilgileniyor olabiliriz. Onun için yardımcı bir metod yazacağım:

.safe()
[source,javascript]
----
const safe = pred => x => (pred(x)
                            ? new Just(x)
                            : new Nothing())
safe(x => x > 5)(10) // Just 5
safe(x => x > 5)(0)  // Nothing
----

(`Maybe.of` metoduna da artık ihtiyacım kalmadı)

[TIP]
====
`chain` metodu farklı isimlerle anılabiliyor:

. chain
. flatMap
. bind

====

=== Luhn dogrulama - devam

Bundan sonrası oldukça basit. Tüm doğrulama adımlarını sırasıyla ekleyeceğim.

++++
<iframe src='https://gfycat.com/ifr/TotalGrandIrishwaterspaniel' frameborder='0' scrolling='no' allowfullscreen width='640' height='390'></iframe>
++++

Koduma feature'lari ekledikçe onları REPL'e yollayarak test ediyorum. Bu test davranışlarını da koduma kaydediyorum.

=== Sonuc

.luhn metodu
[source,javascript]
----
const sumList = l => l.reduce((a, b) => a + b, 0)

const luhn = str => (
  new Just(str)
    .map(x => x.split(""))
    .map(l => l.filter(x => x != " "))
    .map(l => l.map(x => parseInt(x)))
    .chain(safe(l => !l.includes(NaN)))
    .chain(safe(l => l.length > 1))
    .map(l => l.reverse())
    .map(l => l.map((x, i) => i % 2 == 1
                                ? (x * 2)
                                : x))
    .map(l => l.map(x => x >= 10
                           ? (x - 9)
                           : x))
    .map(sumList)
    .map(x => x % 10 == 0)
    .withDefault(false)
)

luhn("4539 1488 0343 6467") == true || fail("valid num")
luhn("1") == false || fail("too short")
luhn("123 a 456") == false || fail("has unknown chars")
sumList([1, 2, 3]) == 6 || fail("sumList 1 2 3")
----

== Luhn Online REPL

http://repl.it[Repl.it]'i henüz keşfettim. Hem tüm kodu sizlerle paylaşmama, hem de sizlere kod ile oynama imkanı sunuyor.

++++
<iframe height="400px" width="100%" src="https://repl.it/@aecepoglu/Luhn-Validation?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
++++

'''

_Birkaç saat geçmiş, çoktan öğlen olmuş ve benim tek yapmak istediğim OCaml ilanlarına bakmak idi..._ +
_"sonraki sefere artık" diyerek öğle yemeğine çıkacağım_ +
_Yolundan sapmış bir sonraki maceramızda görüşmek üzere..._
