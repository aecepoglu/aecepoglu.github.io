<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on aecepoglu</title>
    <link>/posts/</link>
    <description>Recent content in Posts on aecepoglu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>En Güzel JavaScript kodu: Akış Şeması Programlama</title>
      <link>/posts/most-elegant-js-code/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/most-elegant-js-code/</guid>
      <description>route.post(&#34;/api/proxy&#34;, function (req, res) { var saveAnyway = req.body.saveAnyway; var noHealthCheck = req.body.noHealthCheck; function save(proxy) { proxy.save(function (err, saved) { if (err) { res.status(400).send(err.stack); } res.send(saved); }); } Promise.resolve(new ProxyResource(req.body)) .then(function(proxy) { proxy.status = &#34;valid&#34;; if (saveAnyway) { save(proxy); } return proxy; }) .then(function(proxy) { if (!noHealthCheck) { var promises = HealthService.checkProxies([proxy]); Promise.all(promises) .catch(function(error) { save(); }) .then(function(result) { proxy.status = (result &amp;amp;&amp;amp; result[0]) ? &#34;valid&#34; : &#34;invalid&#34;; if (proxy.status == &#34;</description>
    </item>
    
    <item>
      <title>Kurt, Koyun, Ot</title>
      <link>/posts/wolf-sheep-grass/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/wolf-sheep-grass/</guid>
      <description>Bir çobanın bir kurdu, bir koyunu, bir balya da otu var.
Bunları nehrin karşı yakasına taşımak istiyor.
Nehirde bir kayık var.
Kayık ancak çobanı ve bir adet şeyi (ot, koyun ya da kurt) taşıyacak kadar büyük.
Başlarında çoban olmaz ise; kurt kuzuya saldırabiliyor, kuzu ise otu yiyebiliyor.
Çoban herkesi sağ salim nasıl karşıya taşır?
 Evet, farkındayım&amp;#8230;&amp;#8203; Basit bir bulmaca.
 Peki ya bunu kod ile çozecek olsak?
 İleride mantık-proglamlamadan ve declarative programlamadan bahsedeceğim.</description>
    </item>
    
    <item>
      <title>Değişebilirlik(Mutability) Suratınızda Patlayınca</title>
      <link>/posts/immutability-alt/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/immutability-alt/</guid>
      <description>Sıradan bir iş günü. JavaScript&amp;#8217;te tablolarımızdan birisine sayfalar arasında geçiş yaparken veri indir/kaldır yapma kabiliyeti ekliyorum (halk arasında buna &#34;pagination&#34; diyorlar). retrieveItems diye ve drawItems diye birer fonksiyon yazdım. retrieveItemsAndDraw yazıp çözüme ulaşmak üzereyken şu kodu yazdığımı farkediyorum:
 const retrieveAndDrawItems = R.compose(drawItems, retrieveItems)   Ekip arkadaşlarımdan birisi bu satırda n&amp;#8217;aptığımı sorduğunda &#34;Basit!&#34; diye cevaplıyorum:
  Bu iki fonksiyonu birleştirip yeni bir fonksiyon oluşturuyorum.
 De ki f(x) = 2x + 3 demek istiyorum.</description>
    </item>
    
    <item>
      <title>NodeJS&#39;te Maybe Monad&#39;ını Kullanarak REPL-Destekli Kod Yazma</title>
      <link>/posts/repl-driven-development/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/repl-driven-development/</guid>
      <description>http://discuss.ocaml.org &#39;u açıyorum; uzun zamandır portfolyomu fonksiyonel yaklaşımlar ve diller konusunda zenginleştirmekteyim ve de aktif bir iş arayışındayım. İnternette bir OCaml ilanı var ise orada bulabileceğimden eminim.
 Komşu başlıklardan birisinde &#34;Closure&amp;#8217;da REPL Driven Development&#34; yapmanın ne kadar keyifli olduğunu, acaba OCaml&amp;#8217;da da bunun mümkün olup olmadığı tartışılıyor.
  I want to define “Repl based development” not as “occasionally use the REPL”, but something like this:
 we start a REPL we type code in some editor, and continuously “send last expression” to the REPL, and we look at the new output eventually, we clean up the buffer a bit and store it as code</description>
    </item>
    
  </channel>
</rss>