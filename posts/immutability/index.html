<!doctype html>
<html lang="en">
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content='text/html; charset=utf-8' http-equiv='content-type' />

  <title>Bileşke Fonksiyon (compose), Birleştirebilme (Composability), Değişemezlik (Immutability) - aecepoglu</title>
  <meta content='Bileşke Fonksiyon (compose), Birleştirebilme (Composability), Değişemezlik (Immutability) - aecepoglu' property='title' />
  <meta content='Bileşke Fonksiyon (compose), Birleştirebilme (Composability), Değişemezlik (Immutability) - aecepoglu' property='og:title' />


<meta property="og:description" content="Sıradan bir iş günü. JavaScript&#8217;te tablolarımızdan birisine sayfalar arasında geçiş yaparken veri indir/kaldır yapma kabiliyeti ekliyorum (halk arasında buna &#34;pagination&#34; diyorlar). retrieveItems diye ve drawItems diye birer metod yazdım. retrieveItemsAndDraw yazıp cözüme ulaşmak üzereyken şu kodu yazdığımı farkediyorum:
 const retrieveAndDrawItems = R.compose(drawItems, retrieveItems)   Ekip arkadaşlarımdan birisi bu satırda n&#8217;aptığımı sorduğunda &#34;Basit!&#34; diye cevaplıyorum, &#34;Aslında olay myCompose = fs &#8658; x0 &#8658; fs.reverse().reduce((x, f) &#8658; f(x), x0)den ibaret~&#34;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/immutability/" />


<meta property="article:published_time" content="2019-08-12T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2019-08-12T00:00:00&#43;00:00"/>








<meta name="generator" content="Hugo 0.40.1" />

<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<style type="text/css">/*https://coolors.co/afd5aa-f0f2ef-a69f98-3d3d3d-8c6057*/
:root {
  --main-color: #8C6056; 
  --secondary-color: #AFD5AA;
  --logo-text-color: #fff;
  --body-text-color: #3d3d3d;
  --heading-text-color: #383838;
  --background-color: #fff;
}</style>
<link href='/css/tachyons.min.css' rel="stylesheet">
<link href='/css/styles.css' rel="stylesheet">
<link href='/css/asciidoctor.css' rel="stylesheet">
<link href='/css/codehl.css' rel="stylesheet">


<link rel="icon" 
 
  href='/favicon.ico'

type="image/x-icon"/>

<link href='/feed.xml' rel="alternate" type="application/atom+xml" title="aecepoglu" />

</head>
<body class="global-font">
  <nav class=" flex-ns justify-between border-box pa3 pl3-l pr2-l mt1 mt0-ns" id="navbar">
  <div class="flex">
    <a class="f4 fw6 ttu no-underline dim bg-main-color pv1 ph2 br2" id="site-title" href='/' title="Home">aecepoglu</a>
  </div>
  
  <div class=" flex-ns mt2 mt0-ns pv1">
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/posts/index.xml' title="rss">rss</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/en/' title="en">en</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/tr/' title="tr">tr</a>
    
      <a class="link dim dark-gray f6 dib mr2 mr3-l ttu tracked" href='/about' title="hakkimda">hakkimda</a>
    
  </div>
  
</nav>
  
<main class="center mv4 content-width ph3">
  <div class="f3 fw6 heading-color heading-font post-title">Bileşke Fonksiyon (compose), Birleştirebilme (Composability), Değişemezlik (Immutability)</div>
  <p class="silver f6 mt1 mb4 post-meta">
    <time>12 Aug 2019</time> 
    
    
    
  </p>
  <div class="lh-copy post-content"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Sıradan bir iş günü.
JavaScript&#8217;te tablolarımızdan birisine sayfalar arasında geçiş yaparken veri indir/kaldır yapma kabiliyeti ekliyorum (halk arasında buna "pagination" diyorlar).
<code>retrieveItems</code> diye ve <code>drawItems</code> diye birer metod yazdım. <code>retrieveItemsAndDraw</code> yazıp cözüme ulaşmak üzereyken şu kodu yazdığımı farkediyorum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="kd">const</span> <span class="nx">retrieveAndDrawItems</span> <span class="o">=</span> <span class="nx">R</span><span class="p">.</span><span class="nx">compose</span><span class="p">(</span><span class="nx">drawItems</span><span class="p">,</span> <span class="nx">retrieveItems</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ekip arkadaşlarımdan birisi bu satırda n&#8217;aptığımı sorduğunda <em>"Basit!"</em> diye cevaplıyorum, <em>"Aslında olay <code>myCompose = fs &#8658; x0 &#8658; fs.reverse().reduce((x, f) &#8658; f(x), x0)</code>den ibaret~"</em>.</p>
</div>
<div class="paragraph">
<p>Ama o cevap yanlış, ve <code>compose</code> (yani metod-birleştirme) basit olsa da oldukça önemli bir konu. Bu yazı yukaridaki <code>myCompose</code>u anlama, anlatma ve çözme uğruna yazılmış bir yazı&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bileşke_fonksiyon">Bileşke fonksiyon</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Bileşke fonksiyon</em>u matematikten hatırlıyorsunuz değil mi? Birden fazla fonksiyonu tek bir fonksiyon  altinda birleştirmeye yarıyor. <em>Bileşke</em>, <em>birleştirebilme</em> (yani "composability"); fonksiyonel programlamada "mödülerlik" elde edebilmek için yegane silahımız.</p>
</div>
<div class="listingblock">
<div class="title">f,g,fog</div>
<div class="content">
<pre>f(x) = x + 2
g(x) = x * 3
(fog)(x) = f(g(x)) = (3 * x) + 2</pre>
</div>
</div>
<div class="listingblock">
<div class="title">f,g,fog JavaScript&#8217;te</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="nx">g</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">3</span>
<span class="nx">fog</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_bileşke_fonksiyonu_inşaa_etmek">Bileşke fonksiyonu inşaa etmek</h3>
<div class="paragraph">
<p>2 metodu alıp birleştiren bir metod yazmak niyetindeyim; ama önce metodlarin girdi ve çıktı tiplerini tanımlamak istiyorum ki hangi metodların nasıl birleşebildiğini görelim.</p>
</div>
<div class="paragraph">
<p>Fonksiyonel dillerde metodların tiplerini tanımlarken Haskell kökenli bir yaklaşım kullanılıyor:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>string &#8594; int</code> : bir metod. <code>string</code> alıp <code>int</code> dönüyor</p>
</li>
<li>
<p><code>f :: string &#8594; int</code>: <code>f</code> adındakı metod <code>string</code> alıp <code>int</code> dönüyor</p>
</li>
<li>
<p><code>int &#8594; int &#8594; int</code>: 2 <code>int</code> alıp bir <code>int</code> dönen bir metod</p>
</li>
<li>
<p><code>indexOf: [string] &#8594; int</code>: <code>string</code> listesi alıp <code>int</code> dönen bir metod. mesela: <code>indexOf</code></p>
</li>
<li>
<p><code>find :: ['a] &#8594; Maybe 'a</code>: herhangi bir tipte (<code>a</code>) bir liste alıp, içinde o tip olan bir <code>Maybe</code> donen bir metod.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Artık metodları tanımlamak için ortak dili kullanabildiğimize göre bileşke fonksiyonlara tekrar bakalım:</p>
</div>
<div class="listingblock">
<div class="title">f,g,fog JavaScript&#8217;te</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="nx">g</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">3</span>
<span class="nx">fog</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Aslında ben <code>f</code>'nin ve <code>g</code>'nin ne alip ne verdiğini biliyorsam, ikisinin birleşimi olan <code>fog</code>'un da ne alıp verdiğini bilebilirim.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>f :: 'a -&gt; 'b
g :: 'b -&gt; 'c
fog :: 'a -&gt; 'c</pre>
</div>
</div>
<div class="paragraph">
<p>Biraz daha somut örnekler verecek olursak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="c1">//myParseInt :: string -&gt; int</span>
<span class="nx">myParseInt</span> <span class="o">=</span> <span class="nb">parseInt</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="c1">//indexOf :: 'a -&gt; ['a] -&gt; int</span>
<span class="nx">indexOf</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">xs</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>

<span class="c1">//increment :: int -&gt; int</span>
<span class="nx">increment</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1">//uppercase :: string -&gt; string</span>
<span class="nx">uppercase</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span>

<span class="c1">// cities :: [string]</span>
<span class="nx">cities</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">ANKARA</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">ISTANBUL</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">KAYSERI</span><span class="dl">"</span><span class="p">]</span>

<span class="c1">// indexOfCity :: string -&gt; int</span>
<span class="nx">indexOfCity</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">indexOf</span><span class="p">(</span><span class="nx">uppercase</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>parseInt</code> sayıya dönüşteremediği değerler için <code>NaN</code> dönüyor ama şimdilik onu görmezden gelin.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>indexOfCity</code> metodu <code>indexOf</code> ile <code>uppercase</code> metodlarının bileşimi. <code>(fog)(x)</code> örneğindeki gibi ancak <code>f</code> yerinde <code>indexOf</code>, <code>g</code> yerinde <code>uppercase</code> var.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Aynı biçimde <code>uppercase(myParseInt("4"))</code>'un sorunlu, <code>increment(myParseInt("4"))</code>'un ise sorunsuz olduğu da görulebilir.</p>
</div>
<div class="paragraph">
<p>Dediğim gibi, problemleri metodlar şeklinde parçalayıp, metodların birleşimi şeklinde çözümler sunmak fonksiyonel programlamadaki en temel yaklaşımlardan. Bu yüzdendir ki <code>Haskell</code>'de iki fonksiyonun bileşkesini almak <code>.</code> yazmak kadar kolay:</p>
</div>
<div class="listingblock">
<div class="title">Haskell&#8217;de bileşke fonksiyon</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><span class="n">indexOfCity</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexOf</span> <span class="o">.</span> <span class="n">uppercase</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>JavaScript&#8217;te ise bunu kendimiz inşaa etmek durumundayız:</p>
</div>
<div class="listingblock">
<div class="title">f,g,fog JavaScript&#8217;te</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="c1">//compose :: (('b -&gt; 'c), ('a -&gt; 'b)) -&gt; 'a -&gt; 'c  </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="nx">compose</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>

<span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="nx">g</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">3</span>
<span class="nx">fog</span> <span class="o">=</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Eğer karmaşık geliyorsa durun ve burada n&#8217;olduğunu anlayana kadar bekleyin</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hatta ayni şeyi OCaml&#8217;de yapıp <code>compose</code>'un tipini sorgulatacak olursam:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://i.postimg.cc/gjGJHL1w/2019-08-09-143835-754x378-scrot.png" alt="OCaml compose">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>OCaml&#8217;da bir <code>f</code> adindaki bir metodu <code>x</code> ve <code>y</code> argümanlarıyla cağırmak için <code>f(x, y)</code> değil <code>f x y</code> deriz.</p>
</div>
<div class="paragraph">
<p><code>+</code> ve <code>-</code> gibi işlemler <code>x + 2</code> örneğindeki gibi iki argümanın arasına konulur. Eğer istersek biz de başa-konulan <em>(prefix)</em> metod yazabildiğimiz gibi araya-konulan <em>(infix)</em> metod yazabiliriz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="ocaml"><span class="k">let</span> <span class="p">(</span><span class="o">&gt;&lt;</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
<span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="k">let</span> <span class="n">g</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">3</span>
<span class="k">let</span> <span class="n">fog</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&gt;&lt;</span> <span class="n">g</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Ama OCaml&#8217;da <code>|&gt;</code> operatörü `compose`a tercih ediliyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="ocaml"><span class="k">let</span> <span class="n">fog</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|&gt;</span> <span class="n">g</span> <span class="o">|&gt;</span> <span class="n">f</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>|&gt;</code> operatörünün JavaScript&#8217;e eklenmesi için <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator">bir öneri de var</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Kakoune&#8217;da imleci istediğim metodun üzerine getirip <code>:lsp-hover</code> dediğimde, o değerin tipini ve (var ise) tanımını görebiliyorum.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_genel_geçer_bir_compose_metodu">Genel-Geçer bir compose metodu</h3>
<div class="paragraph">
<p>Bazen 2 değil, daha fazla sayıda metodu birleştirmek isteyebiliyorum. JavaScript&#8217;te bunu yapmak da yeterince basit:</p>
</div>
<div class="listingblock">
<div class="title">fonksiyonları birleştirmeye calışan masum bir kod</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="nx">compose</span> <span class="o">=</span> <span class="nx">fs</span> <span class="o">=&gt;</span> <span class="nx">x0</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">fs</span> <i class="conum" data-value="1"></i><b>(1)</b>
                        <span class="p">.</span><span class="nx">reverse</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b>
                        <span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">x0</span><span class="p">)</span>
                      <span class="p">)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>compose</code>'u <code>compose = (&#8230;&#8203;fs) &#8658; &#8230;&#8203;</code> şeklinde de tanımlayabilirdim</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>compose([f, g])(x)</code> demek <code>g(f(x))</code> değil de <code>f(g(x))</code> demek oldugu icin önce listeyi tersine çeviriyorum. Çünkü <code>reduce</code> sondan başa doğru değil, baştan sona doğru gidiyor.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>Yukarıdaki kodu okuyup örümcek hisleri gıdıklanan?</em></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Yukarıdaki <code>compose</code> metodu <strong>CALIŞMIYOR</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>Peki neden calışmıyor?</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="kd">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">3</span>
<span class="kd">const</span> <span class="nx">h</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>

<span class="kd">const</span> <span class="nx">hfg</span> <span class="o">=</span> <span class="nx">compose</span><span class="p">([</span><span class="nx">h</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">])</span>

<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 289</span>
<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 81</span>
<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 289</span>
<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 81</span>
<span class="c1">//ve sonsuza kadar boyle devam ediyor</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hfg</code>'nin once <code>h(g(f(x)))</code> yaptığını, sonra <code>f(g(h(x)))</code> yaptığını farkettiniz mi?</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_değişemezlik">Değişemezlik</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="kd">const</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">3</span>
<span class="kd">const</span> <span class="nx">h</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span>

<span class="kd">const</span> <span class="nx">funs</span> <span class="o">=</span> <span class="p">[</span><span class="nx">h</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">g</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">hfg</span> <span class="o">=</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">funs</span><span class="p">)</span>

<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 289</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">funs</span><span class="p">)</span> <span class="c1">// [ [Function: g], [Function: f], [Function: h] ]</span>
<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 81</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">funs</span><span class="p">)</span> <span class="c1">// [ [Function: h], [Function: f], [Function: g] ]</span>
<span class="nx">hfg</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="c1">//sonuc 289</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık sağır Sultan da, onun bilgisayar mühendisliği okuyan kızıyla sohpet ederken <em>"a benim bilgisayar da cok yavaşladı, n&#8217;apsak buna? Sen format atmayı biliyo musun?"</em> diyen ve istemediği cevabı alınca da <em>"E ne anladık bundan! Bizim mahalledeki bilgisayar tamircisi bile bilir bunu"</em> diyen eniştesi de problemin n&#8217;olduğunu anladı galiba.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://i.pinimg.com/736x/bd/fe/98/bdfe98a28b94edc7d30487099e935227.jpg" alt="IT Crowd&#8217;da Jen&#8217;in masaüstü">
</div>
<div class="title">Orneğin: sağır Sultan&#8217;in eniştesinin bilgisayari</div>
</div>
<div class="paragraph">
<p><code>Array</code>'in <code>reverse</code> metodu, üzerinde çağırıldığı <code>array</code>'i değiştiriyor.<br>
Yani <code>reverse</code> metodu <code>mutative</code> .</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_değiştirebilir_mutative_fonksiyon">Değiştirebilir (Mutative) Fonksiyon</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Değiştirebilir</strong> (mutative) fonksiyon adi ne diyorsa onu yapiyor; <strong>değiştirebilir</strong> fonksiyon programın <strong>vaziyet</strong>ini değiştir(ebil)iyor.</p>
</div>
<div class="paragraph">
<p><strong>Vaziyet</strong> tanımını daha açık hale getirmek adına önce "fonksiyon"un tanımını yapmak lazım.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Ruby&#8217;de mutative fonksiyonlarin adlarının sonunda <code>!</code> oluyor. Bir metodun adı <code>reverse</code> değil de <code>reverse!</code> ise biliyorsunuz ki bu metod bir yerlere müdahele ediyor.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_saf_fonksiyon">Saf Fonksiyon</h3>
<div class="paragraph">
<p>Matematikte (hatırlarsanız) fonksiyon bir kümeden bir kümeye giden bir bağıntıya denir.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://i.postimg.cc/gjYf97g7/untitled.png" alt="fonksiyon semasi">
</div>
<div class="title">Orneğin:A&#8217;dan B&#8217;ye giden bir fonksiyon</div>
</div>
<div class="paragraph">
<p>Bu fonksiyona <code>fab</code> ismini verip JavaScript&#8217;te yazalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="kd">const</span> <span class="nx">A2B</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>
<span class="nx">fab</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">A2B</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fab</code> A&#8217;dan B&#8217;ye giden bir fonksiyon olduğu gibi, <code>f(x) = 2x + 3</code> gibi tam sayılarda tanımlı bir fonksiyon da olabilir.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://i.postimg.cc/LsZXhxz5/untitled-1.png" alt="fonksiyon semasi">
</div>
<div class="title">Örneğin:Z&#8217;den Z&#8217;ye giden <code>f(x) = 2x + 3</code> fonksiyonu</div>
</div>
<div class="paragraph">
<p><code>fab</code> ve <code>f(x) = 2x + 3</code> gibi tek yaptığı bir kümeyi başka bir kümeye bağlamak olan fonksiyonlara programlamada <strong>saf</strong> denir. <strong>Saf fonksiyon</strong> tanımı <strong>yan etki</strong> açıklanınça daha anlaşılır olacak:</p>
</div>
</div>
<div class="sect2">
<h3 id="_yan_etki">Yan Etki</h3>
<div class="paragraph">
<p><code>fab</code> metodu A kümesini B kümesine bağlamaktan fazlasını yapıyor olsun, mesela bir web sayfasına yazı yazsın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="nx">fabAndEdit</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span>
	<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">#text</span><span class="dl">"</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">x</span>
	<span class="k">return</span> <span class="nx">A2B</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://i.postimg.cc/gkdND5j9/untitled-2.png" alt="yan etkili fonksiyon semasi">
</div>
<div class="title">Örneğin:fabAndEdit</div>
</div>
<div class="paragraph">
<p>Bu <code>innerHTML</code>'nin atanışı gibi, girdi-çıktı bağıntısı dışında olan etkilere <strong>yan etki</strong> diyoruz.</p>
</div>
<div class="paragraph">
<p>Yan etki pröğramın vaziyetini değiştiren her şey olarak da düşünülebilir.</p>
</div>
<div class="paragraph">
<p><strong>Vaziyet</strong> (state) pröğramın/bilgisayarın o anki halidir. Örneğin siz klavyede bir tuşa basınca bilgisayarin <strong>vaziyet</strong>ini bir-tuşu-basılı-bilgisayar vaziyetine dönüştürürsünüz. Bir fonksiyonda bir metin-kutusuna (textbox) müdahele ederseniz artık programın <strong>vaziyet</strong>i değişmiştir, o metin-kutusunda evvelde yazmayan bir şey yazıyordur; başka bir kod o metin-kutusunun değerini degiştikten sonra okuyacak olursa, değiştikten önce okuyacağından başka bir değer bulacaktır.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Programın <strong>vaziyet</strong>ine müdahele etmeyen fonksiyonlara <strong>saf fonksiyon</strong> denir.</p>
</li>
<li>
<p>Bir fonksiyon programın <strong>vaziyet</strong>ine müdahele ediyor ise, bu müdaheleye <strong>yan etki</strong> denir.</p>
</li>
<li>
<p><strong>Saf fonksiyon</strong>larin <strong>yan etkisi</strong> yoktur. <strong>Yan etkisi</strong> olan fonksiyonlar <strong>saf</strong> değildir.</p>
</li>
<li>
<p><strong>Saf fonksiyonlar</strong> ne zaman cağırılırsa çağırılsın, her zaman aynı girdi için aynı sonucu verir.</p>
</li>
<li>
<p><strong>Değiştirebilir</strong> fonksiyonların yan etkileri vardır. <strong>Değiştirebilir</strong> fonksiyonlar saf değildir.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_değiştirebilir_fonksiyonlarin_zihinsel_yükü">Değiştirebilir Fonksiyonlarin Zihinsel Yükü</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Bir insanın short-term memory&#8217;sinde tutabileceği sey sayısı 7±2&#8217;dir</p>
</div>
</blockquote>
<div class="attribution">
&#8212; George A. Miller<br>
<cite>The Magical Number Seven</cite>
</div>
</div>
<div class="paragraph">
<p>Zihinsel kapasitemiz sınırsız değil; zaten benim gibiyseniz bir kulağınızla podcast dinliyorsunuz, bir kulağınızla da <em>"acaba benimle ilgili bir şey mi konuşuluyor"</em> diye toplantı odasından gelen sesleri dinler iken kod yazıyorsunuz.</p>
</div>
<div class="paragraph">
<p>Bu haldeyken yazdığınız koddaki her bir metod cağrısının  acaba programın vaziyetini nasıl değiştirdiğini, global değişkenlere nasıl müdahele ettiğini, verdiğiniz argümanlari değiştirip değiştirmedigini kendinize zihinsel yük edinmemek adına kodunuzu olabildiğince <strong>saf</strong> yazmak, <strong>Yan etkileri</strong> (var ise) sınırlı kullanmak kodun sürdürülebilirliğini arttıracaktır (ki yan etkisi olmayan program olmaz; kullanıcıdan girdi almayan ve kullanıcıya çıktı vermeyen programın manası yoktur. Felsefe yapıp çıktısı görülemeyen programın var olmadığını bile iddia edebiliriz).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Yan etkiler tembelleştirilerek fonksiyonlar saflaştırılabilir.</p>
</div>
<div class="paragraph">
<p>Açıklayayım&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Bir fonksiyon sonucunu hemen üretmiyorsa, sonucun tam olarak ihtiyaci duyulan ana kadar bekletiyorsa ona tembel denir. Haskell mesela doğal olarak tembel bir dil, OCaml`da ise herhangi bir degeri <code>lazy</code> ilan ederek bunu yapabiliyoruz. JavaScript&#8217;te ise (her zaman oldugu gibi) icat yapmamız gerekiyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="nx">incrCounter_unsafe</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">counter</span> <span class="o">++</span><span class="p">}</span>
<span class="nx">incrCounter</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">counter</span> <span class="o">++</span><span class="p">}</span>

<span class="nx">range</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="p">[]</span>
               <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="nx">l</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">}</span>
               <span class="k">return</span> <span class="nx">l</span> <span class="p">}</span>

<span class="nx">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="nx">range</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">incrCounter_unsafe</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nx">lazyFuns</span> <span class="o">=</span> <span class="nx">range</span><span class="p">(</span><span class="mi">4</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">incrCounter</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="nx">lazyFuns</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">())</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>[0, 1, 2]</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>ekrana <code>0</code> yazar</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ekrana <code>3</code> yazar</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>ekrana <code>0</code> yazar</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>ekrana <code>4</code> yazar</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>incrCounter_unsafe</code> global değişken <code>counter</code>'a mudahele ettigi icin saf değil. <code>incrCounter_unsafe</code> fonksiyonu çağırıldığında hemen gidip yapması gerekeni yapıyor: <code>counter</code> değerini değiştiriyor.</p>
</div>
<div class="paragraph">
<p>Öte yandan <code>incrCounter</code> fonksiyonunu cağırdığımızda hiçbir şey olmuyor, <code>incrCounter</code> bize "ya hic halim yok, bak ben sana istediğini yapan bir şey vereyim, sen onu kullan olur mu?" diyip bir fonksiyon dönüyor. Cevapta gelen bu fonksiyon cağırılana kadar da programın vaziyetine bir müdahele olmuyor; yani <code>incrCounter</code> bu şekilde hem <strong>tembel</strong>, hem de <strong>saf</strong> oluyor.</p>
</div>
<div class="paragraph">
<p>Bu gibi tembel işlemler için genel-geçer bir çözüm yazacak olursak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="kd">class</span> <span class="nx">LazyF</span> <span class="p">{</span>
	<span class="kd">constructor</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>   <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">$f</span> <span class="o">=</span> <span class="nx">f</span> <span class="p">}</span>
	<span class="c1">// map :: LazyF ('a -&gt; 'b) -&gt; ('b -&gt; 'c) -&gt; LazyF ('a -&gt; 'c)</span>
	<span class="nx">map</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> 	     <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">LazyF</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$f</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span> <span class="p">}</span>
	<span class="c1">// chain :: LazyF ('a -&gt; 'b) -&gt; LazyF ('b -&gt; 'c) -&gt; LazyF ('a -&gt; 'c)</span>
	<span class="nx">chain</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> 	     <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">LazyF</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">o</span><span class="p">.</span><span class="nx">performUnsafe</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">$f</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span> <span class="p">}</span>
	<span class="c1">// performUnsafe :: LazyF ('a -&gt; 'b) -&gt; 'a -&gt; 'b</span>
	<span class="nx">performUnsafe</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nx">foo</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">x: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
<span class="nx">foo</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="k">new</span> <span class="nx">LazyF</span><span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="k">new</span> <span class="nx">LazyF</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">performUnsafe</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="k">new</span> <span class="nx">LazyF</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">performUnsafe</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <i class="conum" data-value="4"></i><b>(4)</b>

<span class="nx">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1">//incrCounter :: () -&gt; LazyF (() -&gt; ())</span>
<span class="nx">incrCounter</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">LazyF</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="nx">counter</span> <span class="o">++</span><span class="p">})</span>
<span class="nx">lazy</span> <span class="o">=</span> <span class="p">(</span><span class="nx">incrCounter</span><span class="p">()</span>
          <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">incrCounter</span><span class="p">())</span>
          <span class="p">.</span><span class="nx">chain</span><span class="p">(</span><span class="nx">incrCounter</span><span class="p">()))</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <i class="conum" data-value="5"></i><b>(5)</b>
<span class="nx">lazy</span><span class="p">.</span><span class="nx">performUnsafe</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">)</span> <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ekrana <code>x: 5</code> yazıp <code>6</code> döner</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>LazyF {'$f': [Function: foo]}</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>ekrana <code>x: 5</code> yazip <code>6</code> döner</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>ekrana <code>x: 5</code> ve <code>x: 6</code> yazıp <code>7</code> döner</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>ekrana <code>0</code> yazar</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>ekrana <code>3</code> yazar</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Haskell&#8217;de her tür yan etki IO haznelerine konularak saf kod yazılıyor
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Yukarıdaki <code>LazyF</code>'e benzer bir çözümü <a href="https://crocks.dev/docs/crocks/Arrow.html"><code>crocks</code> isimli bir kütüphanede <code>Arrow</code> olarak bulabilirsiniz</a>
</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_değişebilirlik_mutability_değişemezlik_immutability">Değişebilirlik (Mutability), Değişemezlik (Immutability)</h3>
<div class="paragraph">
<p>Aslında <strong>değiştirebilirlik</strong> ile iç içe bir kavram. JavaScript&#8217;teki Array ile aşağıda yazdığım ImmutableArray&#8217;in davranışını bi' karşılaştırın:</p>
</div>
<iframe height="600px" width="100%" src="https://repl.it/@aecepoglu/Immutable-Array?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>
<div class="paragraph">
<p>Array&#8217;in <code>push</code> metodunda programda varolan değerleri deşiştirir iken <code>ImmutableArray</code>'in <code>push</code> metodu varolan değerlere asla dokunmuyor. ImmutableArray gibi kendi vaziyetini koruyan nesnelere/değişken-tiplerine <strong>değişemez</strong> (immutable) deniyor. <strong>Değişemez</strong> değerler kullanıldıkları fonksiyonların saflaşmasını da teşvik ediyor.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Fonksiyonel programlama dillerinde <strong>değişemez</strong> değerleri kullanmak için çabalamaya gerek yok; doğal ve kolay bir şekilde destekleniyorlar.</p>
</div>
<div class="paragraph">
<p>Mesela OCaml&#8217;da imperative dillerden alışık olunan <strong>değişken</strong> yok. Zaten matematikteki değişken de aslında ismiyle çakışıyor; <code>g = 9.8</code> dedikten sonra formülün içerisinde <code>g</code>'nin değerini değiştirmiyorsak değişken aslında değişken değildir, değil mi?<br></p>
</div>
<div class="paragraph">
<p>OCaml&#8217;da <code>let a = 5</code> dendikten sonra <code>a</code> etiketi her zaman <code>5</code> değerine eşittir. <code>let counter = ref 5</code> deyip <code>counter &#8592; !counter + 1</code> diyebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Record kullanımında ise:</p>
</div>
<div class="listingblock">
<div class="title">ocaml mutable records</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="ocaml"><span class="k">type</span> <span class="n">sex</span> <span class="o">=</span> <span class="nc">Male</span> <span class="o">|</span> <span class="nc">Female</span>
<span class="k">type</span> <span class="n">person</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
               <span class="n">age</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
               <span class="n">sex</span><span class="o">:</span> <span class="n">sex</span><span class="p">;</span>
              <span class="p">}</span>

<span class="k">let</span> <span class="n">a_person</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Bruce"</span><span class="p">;</span> <span class="n">age</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span> <span class="n">gender</span><span class="o">=</span><span class="nc">Male</span><span class="p">}</span>
<span class="n">a_person</span><span class="o">.</span><span class="n">sex</span> <span class="o">&lt;-</span> <span class="nc">Female</span> <span class="c">(* HATALI *)</span>

<span class="k">let</span> <span class="n">a_new_person</span> <span class="o">=</span> <span class="p">{</span><span class="n">a_person</span> <span class="k">with</span> <span class="n">name</span><span class="o">=</span><span class="s2">"Caitlynn"</span><span class="p">;</span> <span class="n">gender</span><span class="o">=</span><span class="nc">Female</span><span class="p">}</span> <span class="c">(* OK *)</span>

<span class="k">type</span> <span class="n">changable_person</span> <span class="o">=</span> <span class="p">{</span><span class="k">mutable</span> <span class="n">name</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
                         <span class="n">age</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
                         <span class="k">mutable</span> <span class="n">sex</span><span class="o">:</span> <span class="n">sex</span><span class="p">;</span>
                        <span class="p">}</span>
<span class="k">let</span> <span class="n">a_person2</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="o">=</span><span class="s2">"Bruce"</span><span class="p">;</span> <span class="n">age</span><span class="o">=</span><span class="mi">60</span><span class="p">;</span> <span class="n">gender</span><span class="o">=</span><span class="nc">Male</span><span class="p">}</span>
<span class="n">a_person2</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;-</span> <span class="s2">"Caitlynn"</span>
<span class="n">a_new_person</span> <span class="o">&lt;-</span> <span class="nc">Female</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Siz de immutable kod yazmak istiyorsanız ama ekibinizde JavaScript&#8217;i terkedip OCaml yazmak mümkün değilse <a href="https://github.com/immutable-js/immutable-js">immutableJS</a> kütüphanesi sayesinde primitive değerler olmasa da liste, küme, map gibi veri tiplerini mutable kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p>"Yok istemem" diyorsanız da o zaman size bol <code>clone()</code>'lamalar, bol <code>slice()</code>'lamalar&#8230;&#8203;</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ee_sonuç">Ee&#8230;&#8203; Sonuç?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sonuç basit, çalışan bir compose kodu:</p>
</div>
<div class="listingblock">
<div class="title">compose</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="javascript"><span class="nx">reverseList</span> <span class="o">=</span> <span class="nx">l</span> <span class="o">=&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">slice</span><span class="p">().</span><span class="nx">reverse</span><span class="p">()</span>

<span class="nx">compose</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">fs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x0</span> <span class="o">=&gt;</span> <span class="nx">reverseList</span><span class="p">(</span><span class="nx">fs</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">x</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">x0</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Tabii bana <code>R.compose</code>'un n&#8217;olduğunu soran çocuk tüm bu hikayeyi dinlemeye kalmadı&#8230;&#8203; Olsun, yarın kilitlerim ben onu aynı çok-bilmişlikle~</p>
</div>
</div>
</div>
</div>
</main>
 








<div class="pagination tc tr-l db fixed-l bottom-2-l right-2-l mb3 mb0-l">
  
<a id="scroll-to-top" class="f6 o-0 link br2 ph2 pv1 mb1 bg-main-color pointer" onclick="topFunction()" style="color: #fff; visibility: hidden; display: none; transition: opacity .5s, visibility .5s;" title="back to top">back to top</a>
<br>
  <p class="mb0 mt2">
  <a href="/posts/repl-driven-development/">prev post</a>
  
  </p>
</div>

  <footer class="content-width mt0 mt5-l mb4 f6 center ph3 gray tc tl-l">
  <hr class="dn db-l ml0-l gray w3"><br>
  Powered by <a href="https://gohugo.io/" target="_blank" class="link gray dim">Hugo</a>, based on the <a href="https://github.com/lingxz/er" target="_blank" class="link gray dim">Er</a> theme. <br>
  
</footer>
  


<script type="text/javascript">
var prevScrollpos = window.pageYOffset;
window.onscroll = function() {
  var currentScrollPos = window.pageYOffset;

  

  
  if (document.body.scrollTop > 1000 || document.documentElement.scrollTop > 1000) {
      document.getElementById("scroll-to-top").style.display = "inline";
      document.getElementById("scroll-to-top").style.visibility = "visible";
      document.getElementById("scroll-to-top").style.opacity = "1";
  } else {
      document.getElementById("scroll-to-top").style.visibility = "hidden";
      document.getElementById("scroll-to-top").style.opacity = "0";
  }
  
  prevScrollpos = currentScrollPos;
}


function topFunction() {
  document.body.scrollTop = 0; 
  document.documentElement.scrollTop = 0; 
}



</script>




</body>
</html>